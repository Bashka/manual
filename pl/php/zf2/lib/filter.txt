[[:start|Главная]] > [[:ЯП:ZF2|Zend Framework 2]] > Компоненты фреймворка > **Filter**

===== Фильтрация =====

Пакет [[http://framework.zend.com/manual/current/en/modules/zend.filter.html|Filter]] включает классы, реализующие основную логику фильтров библиотеки. Класс позволяет обработать входные данные для исключения из них нежелательных символов или привести данные в требуемый формат.

Фильтры библиотеки используют два основных метода:

  * Контроллер класса, который принимает конфигурацию фильтра;
  * filter, который принимает фильтруемые данные и возвращает результат фильтрации.

<code php>
$htmlEntities = new Zend\Filter\HtmlEntities();
echo $htmlEntities->filter('&'); // &amp;
</code>

Вызвать фильтр можно так же по его имени:

<code php>
echo StaticFilter::execute('"',
                           'HtmlEntities',
                           ['quotestyle' => ENT_QUOTES] // Опции фильтра
                          );
</code>

===== Стандартные фильтры =====

Пакет ''Filter'' включает множество готовых фильтров. Ниже перечислены некоторые из них:

  * **Базовые типы:**
    * Null - преобразование в null;
    * Boolean - преобразование в логический тип;
    * Int - только целые числа;
    * Digits - только числа (целые и дробные);
    * I18n\Filter\Alpha - только буквенные символы (если передана опция allow_white_space, то еще и пробельные символы);
    * I18n\Filter\Alnum - только буквенные и числовые символы (если передана опция allow_white_space, то еще и пробельные символы);
    * StringToLower - нижний регистр символов;
    * StringToUpper - верхний регистр символов;
    * StringTrim - удаление пробелов с начала и конца строки;

<code php>
$filter = Zend\Filter\StringTrim(['charlist' => ':']);
echo $filter->filter(' This is (my) content:'); // "This is (my) content"
</code>

    * StripNewlines - удаление символов новой строки;
    * StripTags - удаление HTML и XML тегов;
    * HtmlEntities - преобразование HTML сущностей;
    * SeparatorToSeparator - преобразование разделителей;

<code php>
$filter = new Zend\Filter\Word\SeparatorToSeparator(':', '+');
echo $filter->filter('this:is:my:content'); // "this+is+my+content"
</code>

    * CamelCaseToSeparator - разделение CamelCase строки;

<code php>
$filter = new Zend\Filter\Word\CamelCaseToSeparator(['separator' => ':']);
echo $filter->filter('ThisIsMyContent'); // "This:Is:My:Content"
</code>

    * SeparatorToCamelCase - объединение строки в CamelCase;

<code php>
$filter = new Zend\Filter\Word\SeparatorToCamelCase(['separator' => ':']);
echo $filter->filter('this:is:my:content'); // "ThisIsMyContent"
</code>

  * **Функции:**
    * Callback - фильтрация с использование указанной функции. В качестве функции может выступать как имя, так и лямбда-функция;

<code php>
class MyClass{
    public function Reverse($param);
}

$filter = new Zend\Filter\Callback([
  'callback' => ['MyClass', 'Reverse'],
  'options'  => ['param' => 'foo']
]);
print $filter->filter('Hello!');
</code>

  * **Файловая система:**
    * BaseName - только адрес файла в файловой системе;

<code php>
$filter = new Zend\Filter\BaseName();
echo $filter->filter('/etc/passwd'); // "/etc/passwd"
</code>

    * Dir - только адрес каталога в файловой системе;
<code php>
$filter = new Zend\Filter\Dir();
echo $filter->filter('/etc/passwd'); // "/etc"
</code>

    * RealPath - полный адрес в файловой системе без относительных ссылок;

<code php>
$filter = new Zend\Filter\RealPath();
$path   = '/www/var/path/../../mypath';
echo $filter->filter($path); // "/www/mypath"
</code>

  * **Разное:**
    * Blacklist - любые значения кроме перечисленных. Игнорируемые значения формируются с помощью метода ''setList'' или опции ''list'', передаваемой в конструкторе. Метод ''setStrict'' делает проверку "строгой" (с учетом типа);

<code php>
$filter = Zend\Filter\Blacklist;
$filter->setList(['a', 'b', 'c']);
$filter->setStrict(true);
echo $filter->filter('a'); // null
echo $filter->filter('d'); // "d"
</code>

    * Whitelist - метод аналогичен ''Blacklist'', но выполняет обратную функцию;
    * PregReplace - преобразование на основе регулярного выражения;

<code php>
$filter = new Zend\Filter\PregReplace([
  'pattern' => '/[^a-b]/',
  'replacement' => ''
]);
echo $filter->filter('Hello world 123'); // "Helloworld"
</code>

    * UriNormalize - нормализация URI.