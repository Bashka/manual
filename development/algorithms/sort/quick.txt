====== Описание ======
Быстрая сортировка - это разделение массива на две части (путем определение базиса) и обмен элементами между частями так, чтобы элементы левой части были меньше элеметов в правой части. После данной процедуры полученные части можно отсортировать (можно рекурсивно с помощью того же алгоритма) и объединить в отсортированный массив.

====== Свойства ======
^ Свойство ^ Значение ^
|Лучшее время|n log n|
|Среднее время|n log n|
|Хучшее время|n<sup>2</sup>|
|Лучшая память|1|
|Средняя память|1|
|Худшая память|1|

====== Реализация ======
<slider>
{{ .:media:quick:step0.png |Начальное состояние}}
Начальное порядок элементов.
<slider>
{{ .:media:quick:step1.png |Шаг 1}}
Определение <color green>базиса</color>.
<slider>
{{ .:media:quick:step2.png |Шаг 2}}
<color red>Левый</color> элемент меньше <color blue>правого</color> - обмен не производится.
<slider>
{{ .:media:quick:step3.png |Шаг 3}}
<color red>Левый</color> элемент меньше <color green>базиса</color> - сдвиг указателя вправо. <color blue>Правый</color> элемент больше <color green>базиса</color> - сдвиг указателя влево. <color red>Левый</color> элемент меньше <color blue>правого</color> - обмен не производится.
<slider>
{{ .:media:quick:step4.png |Шаг 4}}
<color red>Левый</color> элемент больше <color green>базиса</color> - сдвиг не производится. <color blue>Правый</color> элемент больше <color green>базиса</color> - сдвиг указателя влево.
<slider>
{{ .:media:quick:step5.png |Шаг 5}}
<color red>Левый</color> элемент больше <color blue>правого</color> - обмен элементами.
<slider>
{{ .:media:quick:step6.png |Шаг 6}}
<color red>Левый</color> элемент больше <color green>базиса</color> - сдвиг не производится. <color blue>Правый</color> элемент больше <color green>базиса</color> - сдвиг указателя влево.
<slider>
{{ .:media:quick:step7.png |Шаг 7}}
<color red>Левый</color> элемент больше <color blue>правого</color> - обмен элементами.
</slider>

Для реализации необходимо:
  * Найти базис массива - как правило, это среднее значение в массиве;
  * Выбрать наименьший (i) и наименьший (j) индексы массива;
  * Если элемент с индексом i больше элемента с индексом j, поменять их местами;
  * Увеличить i на единицу, если элемент с индексом i меньше базиса;
  * Уменьший j на единицу, если элемент с индексом j больше базиса;
  * Повторить проверку;
  * Отсортировать полученные части массива и объединить их.

<code>
function qsort(&array, imin, imax)
  base = array[(imin + imax) / 2]
  i = imin
  j = imax
  
  while i < j
    if array[i] > array[j]
      tmp = array[i]
      array[i] = array[j]
      array[j] = tmp
    if array[i] < base
      i++
    if array[j] > base
      j--;
  
  if imin + 1 < j
    qsort(array, imin, j)
  if i < imax
    qsort(array, i, imax)
</code>

~~DISQUS~~
